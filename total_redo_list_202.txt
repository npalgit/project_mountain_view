[done] array/addBin.py:15:REDO: do it recursively
[done] array/firstMissingPos.py:11:REDO: need to figure out the trick first try. the corner cases on annoying.
[done] array/fourSums.py:16:REDO. even tho got this on the first try, after doing 3Sum, avoid duplicates annoying
[done] array/gasStation.py:12:REDO: need to find the pattern. I don't like this question that much. need to solve with no hints
[done] array/jumpGame.py:12:REDO: maybe not top priority, its like the max subarray problem. Do it without looking at the solution.
[done] array/longestNonRepeatingSubstring.py:15:REDO for better practice.
[done] array/majorityElements.py:9:REDO: moore's majority algo
[done] array/maxProductSubArray.py:9:REDO
[done] array/medianTwoSortedArray.py:18:REDO this problem
[done] array/minSubarraySum.py:14:REDO: optional, look up O(nlog(n)) solution.
[done] array/minWindowSubstr.py:18:REDO: must get slide window first try
[done] array/nextPerm.py:78:REDO: smart algo
[done] array/removeDuplicatesTwo.py:12:REDO: same principle applies to remove 3 or 4
[done] array/removeElement.py:13:REDO: do it fast in the most efficient solution. And fix removeElement2
[done] array/rotateArr.py:11:REDO: the method with mod.
[done] array/slidingMaxWin.py:21:REDO: good use of deque
[done] array/sortColors.py:11:REDO: many different algorithms. a few more than these. Do this without looking at sol. also dutch national flag. Four way partition?
[done] array/threeSums.py:16:REDO defintily
[done] array/threeSumsClosest.py:10:REDO, and also all the sums. And various solutions.
[done] backtracking/combinations.py:19:REDO: this as a series of backtracking
[done] backtracking/comboSum.py:4:REDO: good question to redo. DP is actually slower. Also redo backtracking
[done] backtracking/comboSumDup.py:20:REDO: good structure for backtracking. redo with dp
[done] backtracking/nQueens.py:5:REDO: the backtrack solution.
[done] backtracking/palindromePartition.py:15:REDO: go over all the backtracking problems
[done] backtracking/permutationDup.py:13:REDO: figure out the correct condition
[done] backtracking/sudokuSolver.py:7:REDO: good quesiton to get re-acquinted with. did not struggle too much.
[done] backtracking/wordBreak2.py:13:REDO: dfs_mem, bfs_mem, time complexity
bits/bitwiseAndRange.py:7:REDO: smart algorithm
[done] bits/reverseBits.py:12:REDO: good question
bits/singleNumK.py:5:REDO: crazy smart algorithm
dynamicProgramming/burstBalloons.py:25:REDO: great problem
dynamicProgramming/distinctSubsequence.py:12:REDO: and similar ones
dynamicProgramming/editDistance.py:12:REDO
dynamicProgramming/lis.py:13:#REDO: binary search algorithm
dynamicProgramming/maximalRectangle.py:14:REDO: know how to do maxHistogram first. Then just read over the solution. no need to code everything.
dynamicProgramming/regxMatching.py:21:REDO- dp is a little bit complicated with details, this is really a difficult one
dynamicProgramming/russianDoll.py:11:REDO: review the trick if width are the same.
dynamicProgramming/shortestPalinPartition.py:10:REDO: review both solutions, optionally coding them.
dynamicProgramming/stockKTimes.py:5:REDO: excellent, watch out for corner cases. and begining index
dynamicProgramming/wildCardMatching.py:5:REDO: quick for practice. notice the special case invovles preprocessing.
[done] graph/clonegraph.py:18:REDO: Need to get this first try also do BFS.
graph/courseSchedule.py:23:REDO: for practice all the solutions
graph/jumpGame2.py:15:REDO: go over bfs solution.
graph/removeInvalidParenthese.py:13:REDO: great question.
[done] graph/sorroundedRegion.py:18:REDO: classic question no need to recode, be familiar with it
[done] graph/wordSearch.py:27:REDO: need to figure out the correct approach first
[done] linkedList/copyRandomPointer.py:8:REDO: interesting algorithm
linkedList/findNodeCycle.py:7:REDO: being able to solve the math part on your own
[done] linkedList/linkedlistjoint.py:13:REDO: the short code
[done] linkedList/mergeTwoSortedList.py:7:possibly REDO. recursion is very smart. Try to do iteratively
[done] linkedList/reverseInKGrp.py:18:REDO: optionally, do it recursively. Learn how to reverse in one liner.
[done] linkedList/rotateList.py:10:REDO: clever solution
misc/candy.py:11:REDO
misc/divideTwoInts.py:8:REDO: sol very efficient way of dividing.
misc/factorialTrailingZeros.py:7:REDO
misc/fractionToDecimal.py:16:REDO: very good question to redo without any help
[done] misc/generateParentheses.py:15:REDO - really good question
[done] misc/groupAnagrams.py:14:leetcode #49, maybe REDO, to get familiar with python trick syntax
[done] misc/insertIntervals.py:15:#REDO: remember try not to do it in place
misc/largestNumbers.py:10:REDO: quickly briefly know how to implement
[done] misc/longestConseqSeq.py:13:REDO: unique algo never seen before, know both algos
misc/longestValidParentheses.py:11:REDO: everything. very tricky
[done] misc/lru_cache.py:6:REDO: review the trick, as it is a common interview question.
misc/maxGap.py:12:REDO:Trick here is radix sort
misc/onlineMedian.py:5:REDO: reimplement
[done] misc/palinNum.py:9:REDO
[done] misc/permutationSequence.py:17:REDO: smart algorithm and index manipulation
[done] misc/pow.py:6:REDO: good to redo, to know how to implement with closed eyes.
[done] misc/scrambleString.py:6:REDO: learn the logic, no necessarily re-write everything
misc/skyline.py:7:REDO
[done] misc/sqrt.py:6:REDO: many smart solutions, try newton method optional
[done] search/findMinInSortedArray.py:12:REDO: need to figure this out fast with no hint
[done] search/findMinInSortedArrayDup.py:11:REDO
[done] search/findPeakElement.py:12:#REDO: this and all similar bin search problem
[done] search/searchInsertPosition.py:14:REDO: Do it in log(n) different binary search methods.
[done] search/searchMtx2.py:22:REDO: learn the trick
[done] search/searchRange.py:15:REDO: this is based on insert pos. good question
[done] search/searchRotatedArray.py:8:REDO: maybe, got it first try. Do it both iteratively, smartly solution, and 2ndBestSolution
[done] search/searchRotatedArrayDuplicates.py:9:REDO: need to figure out the sol on your own this along with #33
sort/kMostFrequent.py:13:REDO: go over algorithm no need to code everything. look into bucket sort
sort/quickSelect.py:11:REDO: great question
stack/largestHistogram.py:12:REDO: related to 42, make sure can do both solutions and know the difference
[done] stack/minStack.py:19:REDO: figure out how to keep min for all stack
[done] stack/simplyfyPath.py:10:REDO: maybe using stack is smart, did not think of it first try. Figured out the solution once knowing to use stack. simplier solution
stack/trappingWater.py:9:REDO: really proud, solved this myself. But redo for review
[done] string/reverseWordsInStr.py:12:REDO: part where clean space happens
[done] trees/bstIterator.py:11:REDO: must know
[done] trees/buildTreePreInorder.py:5:REDO: can't find the trick right away. Very smart solution
[done] trees/buildUniqueBST.py:14:REDO: must know
[done] trees/countUniqueBST.py:15:REDO: figured out self with hints. must know
[done] trees/de_serializeBT.py:15:REDO: Got this first try on my own. try to redo to practice different order traversal and iterative as tree exercises.
[done] trees/inOrderTrav.py:5:REDO iterative.
[done] trees/kthSmallest.py:5:REDO: the other two methods. the current one is great.
[done] trees/linkedlistToBST.py:6:REDO: got O(nlogn) right away. review with O(n). Also notice pointer doesn't work in python
[done] trees/lowestCommonAnces.py:7:REDO: figure out the algo quick
[done] trees/maxSumPath.py:16:REDO: tricky question with clear algorithm. This is a hard question
[done] trees/nextRightPointer.py:19:REDO: quickly the iterative, sol with O(1) space.
[done] trees/nextRightPointerAnyTree.py:24:REDO: tricky algo.
[done] trees/postOrderTrav.py:6:REDO: as part of review for different traversal techniques. and iterative procedure as well
[done] trees/recoverTree.py:11:#REDO: know how the algo works, no need to recode everything.
[done] trees/rightView.py:15:#REDO: learn the trick quickly, cleaver algo
[done] trees/sumRoot2LeafNumbers.py:19:REDO: Do this fast, review. Got this after seeing the interesting algorithm
[done] trees/treeToLinkedList.py:26:REDO: smart solution
[done] trees/zigZagTraverse.py:20:REDO: make sure can do this first try. should be fast

# 104/202 solved
